Optimizing backtracking parser combinators

naive way is to return a list of results, we can do better
functions to parse 'all' and 'some' of the input
backtracking varients of each parser, but has to pass backtrack list up the parse chain
building up strings from a stream needs to be optimized as well
increase speed by returning only pairs of indexes into the string
  optimized subseq for more speed?
  (values) to pass indexes?
inline macroexpansion, as with destr-match?
build up call graph, inline all non-recursive parsers
can modify call order on normal functions mixed in with parsers to avoid filling in data even more
'many' and 'any' should form tight loops in asm, if they're there at all
base operations are string matching and searching, use SSE?
structure of code
  ht for interpreted functions vs the node/optimized macro
    symbol-name -> (function macro)
  list of chars to string combinator, to specify the format: '->string'
  (parse str (->string (many (one-of "abc")))) =>
  (subseq* str
    (consume-iterate
      (matches (one-of "abc"))))
optimized string slicing type and functions?

memoize parsers based on index
lots of use cases for memoization
  memoize for single character classes, or parts of them
    by detecting repeated structures and character classes

use structs and types to avoid unnecessary string formatting at runtime
if possible, preallocate error structs using macros

generalized success/failure functions to avoid repeating code between interpreted parsers
compiled version will need something more granular

`if` is the only flow control operator, all others macroexpand to it
  this can be abused to allow natural flow control in Parmesan
